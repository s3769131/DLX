library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.ALU_pkg.all;

--!   \brief   Select a mask from those provided by the mask generator.
--!
--!   This entity models the network that selects a certain mask, from those generated by the SHIFTER_mask generator
--!   give a certain address. It basically acts like a multiplexer.
entity SHF_mask_selector is
   generic(
      SHF_MS_NBIT   :  integer  := 32; --!   parallelism of the operand.
      SHF_MS_GRAN   :  integer  := 4); --!   granularity of shift.
   port(
      SHF_MS_masks_in   :  in    std_logic_vector((SHF_MS_NBIT/SHF_MS_GRAN)*(SHF_MS_NBIT+SHF_MS_GRAN)-1 downto 0);
      SHF_MS_addr       :  in    std_logic_vector(log2ceil(SHF_MS_NBIT/SHF_MS_GRAN)-1 downto 0);
      SHF_MS_mask_out   :  out   std_logic_vector(SHF_MS_NBIT+SHF_MS_GRAN-1 downto 0));
end SHF_mask_selector;

architecture dflow of SHF_mask_selector is
  constant MASK_LEN :  integer  := SHF_MS_NBIT+SHF_MS_GRAN;
  
  signal tmp_bus : bus_array((SHF_MS_NBIT / SHF_MS_GRAN - 1) downto 0, (SHF_MS_NBIT + SHF_MS_GRAN - 1) downto 0 );
begin
  TRANSLATION_ROW : for i in 0 to (SHF_MS_NBIT / SHF_MS_GRAN - 1) generate
    TRANSLATTION_COL : for j in 0 to (SHF_MS_NBIT + SHF_MS_GRAN - 1) generate 
      tmp_bus(i, j) <= SHF_MS_masks_in (i * (SHF_MS_NBIT / SHF_MS_GRAN - 1) + j);
    end generate;
  end generate;
  
MUX : for i in 0 to (SHF_MS_NBIT + SHF_MS_GRAN - 1) generate
  SHF_MS_mask_out(i) <= tmp_bus(to_integer(unsigned(SHF_MS_addr)), i);
end generate; 

 --  SHF_MS_mask_out   <= SHF_MS_masks_in ( ( to_integer( unsigned(SHF_MS_addr) ) + 1) * MASK_LEN-1 downto to_integer(unsigned(SHF_MS_addr))*MASK_LEN);

end dflow;

configuration CFG_SHF_MASK_SELECTOR_DFLOW of SHF_mask_selector is
   for dflow
   end for;
end configuration CFG_SHF_MASK_SELECTOR_DFLOW;
